#pragma config(Hubs,  S3, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S4, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ir,             sensorI2CCustom)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S3_C1_1,     LEDBottom,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     leftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C2_1,     rightMotor,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S3_C2_2,     LEDTop,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     lift1,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C1_2,     lift2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     intake,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C2_1,    rightDump,            tServoStandard)
#pragma config(Servo,  srvo_S4_C2_2,    leftDump,             tServoStandard)
#pragma config(Servo,  srvo_S4_C2_3,    lock,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C2_4,    flagLock,               tServoStandard)
#pragma config(Servo,  srvo_S4_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"
#include "JoystickDriver.c"
#include "menu.c"

// Define Servo Names
TServoIndex leftDump = srvo_S4_C2_2;
TServoIndex rightDump = srvo_S4_C2_1;
TServoIndex lock = srvo_S4_C2_3;
TServoIndex flagLock = srvo_S4_C2_4;

/*
Red and Far = Blue and Close
Red and Close = Blue and Far
*/

const int TIME_CHECK_INTERVAL = 500;
const int ENCODER_DELTA_IN_TIME_CHECK_INTERVAL = 500;
int turnSpeed = 55; //50
bool turn = false;

void initializeRobot()
{
	nMotorEncoder[lift1] = 0;
	nMotorEncoder[rightMotor] = 0;
	servo[rightDump] = 100;
	servo[leftDump] = 160;
	servo[lock] = 60;
	servo[flagLock] = 256;
	wait1Msec(250);
  return;
}

void driveMotors(int rightSpeed, int leftSpeed, int wait)
{
	motor[rightMotor] = rightSpeed;
	motor[leftMotor] = leftSpeed;
	wait1Msec(wait);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void turnCounterClockwise(int degrees)
{
	float rotSpeed = 0;
  float heading = 0;

  HTGYROstartCal(gyro);

  wait1Msec(250);

	time1[T2] = 0;

	while(heading < degrees) //gyro is upside down
  {
    while (time1[T2] < 25)
    {
      wait1Msec(1);
    }

    time1[T2]=0;

    rotSpeed = HTGYROreadRot(gyro);
    heading += rotSpeed * 0.025;

    nxtDisplayCenteredBigTextLine(3, "%2.0f", heading);

  	motor[rightMotor] = turnSpeed;
  	motor[leftMotor] = -1*turnSpeed;
  }
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
}

void turnClockwise(int degrees)
{
	float rotSpeed = 0;
  float heading = 0;

  HTGYROstartCal(gyro);

  wait1Msec(250);

	time1[T2] = 0;

	while(heading > -1*degrees) //gyro is upside down
  {
    while (time1[T2] < 25)
    {
      wait1Msec(1);
    }

    time1[T2]=0;

    rotSpeed = HTGYROreadRot(gyro);
    heading += rotSpeed * 0.025;

    nxtDisplayCenteredBigTextLine(3, "%2.0f", heading);

  	motor[rightMotor] = -1*turnSpeed;
  	motor[leftMotor] = turnSpeed;
  }
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
}

void driveWithEncoders(int rightSpeed, int leftSpeed, int value)
{
	nMotorEncoder[rightMotor] = 0;
	if(value > 0)
	{
  	while(nMotorEncoder[rightMotor] < value)
  	{
    	motor[rightMotor] = rightSpeed;
     	motor[leftMotor] = leftSpeed;
     	wait1Msec(10);
		}
	}
	else
	{
  	while(nMotorEncoder[rightMotor] > value)
  	{
    	motor[rightMotor] = rightSpeed;
     	motor[leftMotor] = leftSpeed;
     	wait1Msec(10);
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void driveWithEncodersWithStop(int rightSpeed, int leftSpeed, int value)
{
	long lastTime = nSysTime;
	int lastEncoderValue = nMotorEncoder[rightMotor];
	nMotorEncoder[rightMotor] = 0;
	if(value > 0)
	{
  	while(nMotorEncoder[rightMotor] < value)
  	{
  		if(nSysTime - lastTime > TIME_CHECK_INTERVAL)
	  	{
	  		if (abs(nMotorEncoder[rightMotor] - lastEncoderValue) < ENCODER_DELTA_IN_TIME_CHECK_INTERVAL)
	  		{
	  			turn = true;
	  			break;
	  		}
	  	  lastEncoderValue = nMotorEncoder[rightMotor];
	  	  lastTime = nSysTime;
			}

    	motor[rightMotor] = rightSpeed;
     	motor[leftMotor] = leftSpeed;
     	wait1Msec(10);
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void howToPark(int driveValue, int auto)
{
	if((parkLine == 0 && allianceLine == 0) || (parkLine == 1 && allianceLine == 1)) //bluefar or redclose
	{
		wait1Msec(100);

		short rotSpeed = 0;
  	short heading = 0;

  	HTGYROstartCal(gyro);

  	wait1Msec(250);

  	time1[T2] = 0;

  	nMotorEncoder[rightMotor] = 0;
  	while(nMotorEncoder[lift1] > 305 || heading < 63)
		{
			if(heading < 63)
  		{
    		while (time1[T2] < 25)
    		{
      		wait1Msec(1);
    		}

    		time1[T2]=0;

    		rotSpeed = HTGYROreadRot(gyro);
		   	heading += rotSpeed * 0.025;

		   	nxtDisplayCenteredBigTextLine(3, "%2.0f", heading);

  			motor[rightMotor] = turnSpeed;
  			motor[leftMotor] = -1*turnSpeed;
    	}
    	else
    	{
    		driveMotors(0, 0, 10);
    	}

		  if(nMotorEncoder[lift1] > 305)
		  {
	  		motor[lift1] = -100;
	  		motor[lift2] = -100;
	  	}
	  	else
	  	{
	  		motor[lift1] = 0;
	  		motor[lift2] = 0;
	  	}
	  	wait1Msec(10);
  	}

  	//turnCounterClockwise(thirdTurn);

  	driveMotors(0, 0, 10);
  	motor[lift1] = 0;
  	motor[lift2] = 0;
  	wait1Msec(10);

  	driveMotors(0, 0, 100);

  	nMotorEncoder[rightMotor] = 0;

  	if(driveValue < -450)
  	{
  		//turnCounterClockwise(1);
  		driveWithEncoders(30, 30, 1275 + driveValue);
  	}
  	else if(driveValue > 800)
  	{
  		turnCounterClockwise(1);
 			driveWithEncoders(30, 30, 1270 + driveValue);
  	}
 		else if(driveValue > 0)
 		{
 			//turnCounterClockwise(1);
 			driveWithEncoders(30, 30, 1275 + driveValue);
 		}
 		else
 		{
 			driveWithEncoders(30, 30, 1260 + driveValue);
 		}

  	wait1Msec(250);

		if(driveValue > 0)
		{
		 	driveWithEncoders(-100, 100, -245);
		}
		else
		{
		 	driveWithEncoders(-100, 100, -225); //-225
		}

		wait1Msec(250);

  	driveWithEncoders(100, 100, 1500);

  	wait1Msec(250);

  	driveWithEncoders(-100, 100, -155);

  	wait1Msec(250);

  	driveWithEncoders(100, 100, 700);

		wait1Msec(250);

		driveWithEncoders(-100, 100, -500);

		wait1Msec(250);

		driveMotors(100, 100, 800);
	}
	else if((parkLine == 0 && allianceLine == 1) || (parkLine == 1 && allianceLine == 0)) //blueclose or redfar
	{
		wait1Msec(100);
 		short rotSpeed = 0;
 		short heading = 0;
 		HTGYROstartCal(gyro);
 		wait1Msec(250);
 		time1[T2] = 0;

  	nMotorEncoder[rightMotor] = 0;
  	while(nMotorEncoder[lift1] > 305 || heading > -61)
		{
			if(heading > -61)
  		{
   		 	while (time1[T2] < 25)
	   	 	{
  	  	  wait1Msec(1);
    		}

    		time1[T2]=0;

	    	rotSpeed = HTGYROreadRot(gyro);
  	  	heading += rotSpeed * 0.025;

    		nxtDisplayCenteredBigTextLine(3, "%2.0f", heading);

  			motor[rightMotor] = -1*turnSpeed;
  			motor[leftMotor] = turnSpeed;
    	}
    	else
    	{
    		driveMotors(0, 0, 10);
    	}

   	 	if(nMotorEncoder[lift1] > 305)
    	{
		  	motor[lift1] = -100;
	  		motor[lift2] = -100;
	  	}
	  	else
	  	{
		  	motor[lift1] = 0;
	  		motor[lift2] = 0;
	  	}
	  	wait1Msec(10);
  	}

	  driveMotors(0, 0, 10);
	  motor[lift1] = 0;
	  motor[lift2] = 0;
	  wait1Msec(10);

	  driveMotors(0, 0, 100);

	 	nMotorEncoder[rightMotor] = 0;

	 	if(driveValue < -350)
	 	{
	 		//turnClockwise(1);
	 		driveWithEncoders(30, 30, 1200 - driveValue);
		}
	 	else if(driveValue > 800)
	 	{
 			driveWithEncoders(30, 30, 1430 - driveValue);
 		}
 		else if(driveValue > 0)
	 	{
 			driveWithEncoders(30, 30, 1320 - driveValue);
 		}
 		else
 		{
 			turnClockwise(1);
	 		driveWithEncoders(30, 30, 1250 - driveValue);
 		}

  	wait1Msec(250);

	  driveWithEncoders(100, -100, 305);

	  wait1Msec(250);

	  driveWithEncoders(100, 100, 900);

	  wait1Msec(250);

	  driveWithEncoders(100, -100, 325);

	  wait1Msec(250);

	  driveWithEncoders(100, 100, 800);

		wait1Msec(250);

		if(driveValue > 0)
		{
			driveWithEncoders(100, -100, 730);
		}
		else
		{
			driveWithEncoders(100, -100, 700);
		}

		wait1Msec(250);

		driveMotors(100, 100, 900);
	}
}

void def()
{
	int firstTurn = 77;
	int secondTurn = 80;

	int liftValue = 0;
	bool boundary = false;

  driveWithEncoders(30, 30, 1325);

  wait1Msec(250);

  turnClockwise(firstTurn);

  wait1Msec(250);

  nMotorEncoder[rightMotor] = 0;

	tHTIRS2DSPMode _mode = DSP_1200;
  short dirAC = HTIRS2readACDir(ir);

 	while(dirAC != 5 && !boundary)
  {
  	if(nMotorEncoder[rightMotor] >= 1090)
  	{
  		boundary = true;
  	}
  	dirAC = HTIRS2readACDir(ir);
  	motor[rightMotor] = 30;
  	motor[leftMotor] = 30;
  	wait1Msec(10);
	}

	driveMotors(0, 0, 500);

	while(dirAC != 6 && boundary)
	{
		dirAC = HTIRS2readACDir(ir);
  	motor[rightMotor] = -30;
  	motor[leftMotor] = -30;
  	wait1Msec(10);
	}

	//nxtDisplayBigTextLine(3, "%d", nMotorEncoder[rightMotor]);

	int driveValue = nMotorEncoder[rightMotor];

	driveMotors(0, 0, 250);

	if(driveValue < -450)
	{
		driveWithEncoders(30, 30, 170);
		liftValue = 4000;
	}
	else if(driveValue > 800)
	{
		driveWithEncoders(-30, -30, -80);
		liftValue = 3800;
	}
	else if(driveValue > 100)
	{
		driveWithEncoders(-30, -30, -20);
		liftValue = 3800;
	}
	else
	{
		//driveWithEncoders(-30, -30, 10);
		liftValue = 3900;
	}

 	float rotSpeed = 0;
  float heading = 0;

  HTGYROstartCal(gyro);

  wait1Msec(250);

  time1[T2] = 0;

  long lastTime = nSysTime;
	int lastEncoderValue = nMotorEncoder[rightMotor];

	while(nMotorEncoder[lift1] < liftValue || heading < secondTurn)
	{
		if(heading < secondTurn)
  	{
    	while (time1[T2] < 25)
    	{
    	  wait1Msec(1);
    	}

    	time1[T2]=0;

    	rotSpeed = HTGYROreadRot(gyro);
    	heading += rotSpeed * 0.025;

    	nxtDisplayCenteredBigTextLine(3, "%2.0f", heading);

  		motor[rightMotor] = turnSpeed;
  		motor[leftMotor] = -1 * turnSpeed;
    }
    else
    {
    	driveMotors(0, 0, 10);
    }

    if(nMotorEncoder[lift1] < liftValue)
    {
	  	motor[lift1] = 100;
	  	motor[lift2] = 100;
	  }
	  else
	  {
	  	motor[lift1] = 0;
	  	motor[lift2] = 0;
	  }
	  wait1Msec(10);
  }

  //turnCounterClockwise(secondTurn);

  driveMotors(0, 0, 10);
  motor[lift1] = 0;
  motor[lift2] = 0;
  wait1Msec(10);

  wait1Msec(100);

  if(driveValue > 100)
  {
  	driveWithEncoders(30, 30, 245);
  }
  else
  {
  	driveWithEncoders(30, 30, 240);
  }

	wait1Msec(100);

  servo[rightDump] = 172;
	servo[leftDump] = 110;
	wait1Msec(500);

	wait1Msec(250);

	servo[rightDump] = 90;
	servo[leftDump] = 158;
	wait1Msec(500);

	if(driveValue > 100)
  {
  	driveWithEncoders(-30, -30, -265);
  }
  else
  {
  	driveWithEncoders(-30, -30, -265);
  }
  wait1Msec(100);

  howToPark(driveValue, 1);
}

void intakeAuto()
{
	int firstTurn = 79;
	int secondTurn = 83;

	int liftValue = 0;

  driveWithEncoders(30, 30, 1400);

  wait1Msec(250);

  turnClockwise(firstTurn);

  wait1Msec(250);

  nMotorEncoder[rightMotor] = 0;

	tHTIRS2DSPMode _mode = DSP_1200;
  short dirAC = HTIRS2readACDir(ir);

 	while(nMotorEncoder[rightMotor] <= 1300)
 	{
 		motor[rightMotor] = 30;
 		motor[leftMotor] = 30;
 		if(nMotorEncoder[rightMotor] > 1000)
 		{
 			servo[rightDump] = 155;
	  	servo[leftDump] = 125;
			wait1Msec(10);

 			motor[intake] = 100;
 		}
 		wait1Msec(10);
 	}

	driveMotors(0, 0, 500);

	motor[intake] = 0;
	servo[rightDump] = 100;
	servo[leftDump] = 160;
	wait1Msec(100);

	while(dirAC != 6)
	{
		dirAC = HTIRS2readACDir(ir);
  	motor[rightMotor] = -30;
  	motor[leftMotor] = -30;
  	wait1Msec(10);
	}

	//nxtDisplayBigTextLine(3, "%d", nMotorEncoder[rightMotor]);

	int driveValue = nMotorEncoder[rightMotor];

	driveMotors(0, 0, 250);

	if(driveValue < -150)
	{
		driveWithEncoders(30, 30, 22);
		liftValue = 3750;
	}
	else if(driveValue > 100)
	{
		driveWithEncoders(-30, -30, -50);
		liftValue = 4250;
	}
	else if(driveValue > 1000)
	{
		driveWithEncoders(-30, -30, -160);
		liftValue = 3000;
	}
	else
	{
		driveWithEncoders(-30, -30, -20);
		liftValue = 3750;
	}

 	float rotSpeed = 0;
  float heading = 0;

  HTGYROstartCal(gyro);

  wait1Msec(250);

  time1[T2] = 0;

	while(nMotorEncoder[lift1] < liftValue || heading < secondTurn)
	{
		if(heading < secondTurn)
  	{
    	while (time1[T2] < 25)
    	{
    	  wait1Msec(1);
    	}

    	time1[T2]=0;

    	rotSpeed = HTGYROreadRot(gyro);
    	heading += rotSpeed * 0.025;

    	nxtDisplayCenteredBigTextLine(3, "%2.0f", heading);

  		motor[rightMotor] = turnSpeed;
  		motor[leftMotor] = -1 * turnSpeed;
    }
    else
    {
    	driveMotors(0, 0, 10);
    }

    if(nMotorEncoder[lift1] < liftValue)
    {
	  	motor[lift1] = 100;
	  	motor[lift2] = 100;
	  }
	  else
	  {
	  	motor[lift1] = 0;
	  	motor[lift2] = 0;
	  }
	  wait1Msec(10);
  }

  //turnCounterClockwise(secondTurn);

  driveMotors(0, 0, 10);
  motor[lift1] = 0;
  motor[lift2] = 0;
  wait1Msec(10);

  wait1Msec(100);

  if(driveValue > 0)
  {
  	driveWithEncoders(30, 30, 250);
  }
  else
  {
  	driveWithEncoders(30, 30, 185);
  }

	wait1Msec(100);

  servo[rightDump] = 190;
	servo[leftDump] = 110;
	wait1Msec(500);

	wait1Msec(250);

	servo[rightDump] = 100;
	servo[leftDump] = 160;
	wait1Msec(500);

	if(driveValue > 0)
  {
  	driveWithEncoders(-30, -30, -250);
  }
  else
  {
  	driveWithEncoders(-30, -30, -185);
  }

  wait1Msec(100);

  howToPark(driveValue, 1);
}

void cornBlockL()
{
	driveWithEncoders(100, 100, 325);

  wait1Msec(100);

  driveWithEncoders(100, -100, 552);

  wait1Msec(100);

  driveWithEncoders(100, 100, 2400);

  wait1Msec(100);

  driveWithEncoders(-100, 100, -220);

  wait1Msec(100);

  driveWithEncoders(100, 100, 2425);

  wait1Msec(100);

  driveWithEncoders(-100, 100, -205);

  wait1Msec(100);

  driveWithEncoders(100, 100, 900);

  wait1Msec(100);

  driveWithEncoders(-100, 100, -100);

  wait1Msec(100);

  driveWithEncoders(100, 100, 1400);
}

void cornBlockR()
{
	driveWithEncoders(100, 100, 325);

  wait1Msec(100);

  driveWithEncoders(-100, 100, -210);

  wait1Msec(100);

  driveWithEncoders(100, 100, 2400);

  wait1Msec(100);

  driveWithEncoders(100, -100, 705);

  wait1Msec(100);

  driveWithEncoders(100, 100, 2425);

  wait1Msec(100);

  driveWithEncoders(100, -100, 725);

  wait1Msec(100);

  driveWithEncoders(100, 100, 800);

  wait1Msec(100);

  driveWithEncoders(100, -100, 395);

  wait1Msec(100);

  driveWithEncoders(100, 100, 1500);
}

void blockL()
{
	driveWithEncoders(100, 100, 2900);

  wait1Msec(100);

  driveWithEncoders(-100, 100, -175);

	wait1Msec(100);

	driveWithEncoders(100, 100, 900);

  wait1Msec(100);

  driveWithEncoders(-100, 100, -100);

  wait1Msec(100);

  driveWithEncoders(100, 100, 1400);

  wait1Msec(100);

  driveWithEncoders(100, 100, 100);
}

void blockR()
{
	driveWithEncoders(100, 100, 2425);

  wait1Msec(100);

  driveWithEncoders(100, -100, 725);

  wait1Msec(100);

  driveWithEncoders(100, 100, 800);

  wait1Msec(100);

  driveWithEncoders(100, -100, 395);

  wait1Msec(100);

  driveWithEncoders(100, 100, 1500);
}

task main()
{
	eraseDisplay();
	disableDiagnosticsDisplay();
	menuInit();
	while(menuRunning)
	{
		navigateLines();
		timer();
		autonomousChooser();
		allainceChooser();
		parkChooser();

		if(currentLine == 4)
		{
			nxtDisplayTextLine(4, "*Ready?: Prs Rght");
		}
		else
		{
			nxtDisplayTextLine(4, " Ready?: Prs Rght");
		}

		nxtDisplayTextLine(6, "NXT Bat: %4.1f V", nAvgBatteryLevel/1000);
		nxtDisplayTextLine(7, "Ext Bat: %4.1f V", externalBatteryAvg/1000);

		wait1Msec(225);
	}
	eraseDisplay();
	enableDiagnosticsDisplay();

	initializeRobot();

	waitForStart();

	initializeRobot();

	wait1Msec(1000*delay);

	if(autoLine == 0)
	{
		def();
	}
	else if(autoLine == 1)
	{
		intakeAuto();
	}
	else if(autoLine == 2)
	{
		if((parkLine == 0 && allianceLine == 1) || (parkLine == 1 && allianceLine == 0)) //blueclose or redfar
		{
			cornBlockR(); //named based on initial turn
		}
		else if((parkLine == 0 && allianceLine == 0) || (parkLine == 1 && allianceLine == 1)) //bluefar or redclose
		{
			cornBlockL(); //named based on initial turn
		}
	}
	else if(autoLine == 3)
	{
		if((parkLine == 0 && allianceLine == 1) || (parkLine == 1 && allianceLine == 0)) //blueclose or redfar
		{
			blockR(); //named based on initial turn
		}
		else if((parkLine == 0 && allianceLine == 0) || (parkLine == 1 && allianceLine == 1)) //bluefar or redclose
		{
			blockL(); //named based on initial turn
		}
	}
}
