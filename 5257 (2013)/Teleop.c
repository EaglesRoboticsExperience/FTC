#pragma config(Hubs,  S3, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S4, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ir,             sensorI2CCustom)
#pragma config(Sensor, S2,     gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S3_C1_1,     LEDBottom,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     leftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C2_1,     rightMotor,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S3_C2_2,     LEDTop,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     lift1,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C1_2,     lift2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     intake,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C2_1,    rightDump,            tServoStandard)
#pragma config(Servo,  srvo_S4_C2_2,    leftDump,             tServoStandard)
#pragma config(Servo,  srvo_S4_C2_3,    lock,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C2_4,    flagLock,             tServoStandard)
#pragma config(Servo,  srvo_S4_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-angle.h"
#include "JoystickDriver.c"

// define constants
const int LIFT_MAX_ENCODER_VALUE = 3600;
const int LIFT_MIN_ENCODER_VALUE = 295;
const int TIME_CHECK_INTERVAL = 500;
const int ENCODER_DELTA_IN_TIME_CHECK_INTERVAL = 500;

// Define Servo Names
TServoIndex leftDump = srvo_S4_C2_2;
TServoIndex rightDump = srvo_S4_C2_1;
TServoIndex lock = srvo_S4_C2_3;
TServoIndex flagLock = srvo_S4_C2_4;

bool intakeOn;
bool lifting;
bool hangMode;
bool lowering;
bool initialTurn;

int LEDChange;

task raise()
{
	lowering = false;
	long lastTime = nSysTime;
	int lastEncoderValue = nMotorEncoder[lift1];

	while(nMotorEncoder[lift1] < LIFT_MAX_ENCODER_VALUE) //one of the lift motors has encoder, check which one
	{
		lifting = true;
	  motor[lift1] = 100;
	  motor[lift2] = 100;

	  if(nSysTime - lastTime > TIME_CHECK_INTERVAL)
	  {
	  		if (abs(nMotorEncoder[lift1] - lastEncoderValue) < ENCODER_DELTA_IN_TIME_CHECK_INTERVAL)
	  		{
	  			 break;
	  		}
	  	  lastEncoderValue = nMotorEncoder[lift1];
	  	  lastTime = nSysTime;
		}
  }
  motor[lift1] = 0;
  motor[lift2] = 0;
}

task lower()
{
	lowering = true;
	long lastTime = nSysTime;
	int lastEncoderValue = nMotorEncoder[lift1];

	lifting = false;
	while(nMotorEncoder[lift1] > LIFT_MIN_ENCODER_VALUE)
	{
	 	motor[lift1] = -100;
	 	motor[lift2] = -100;

	 	if (nSysTime - lastTime > TIME_CHECK_INTERVAL)
	 	{
	  		if (abs(nMotorEncoder[lift1] - lastEncoderValue) < ENCODER_DELTA_IN_TIME_CHECK_INTERVAL)
	  		{
	  			 break;
	  		}
	  	  lastEncoderValue = nMotorEncoder[lift1];
	  	  lastTime = nSysTime;
		}

	}
  motor[lift1] = 0;
  motor[lift2] = 0;
}

void drive() //logarithmic modified tank drive
{
  float y1Temp, x2Temp;
  short joyY = joystick.joy1_y1;
  short joyX = joystick.joy1_x2;

  if (joyY >= 0)
  {
  	y1Temp = ((joyY * joyY) / (128.0 * 128.0));
  }
  else
  {
  	y1Temp = ((joyY * joyY) / (128.0 * -128.0));
  }

  if (joyX >= 0)
  {
  	x2Temp = ((joyX * joyX) / (128.0 * -128.0));
  }
  else
  {
  	x2Temp = ((joyX * joyX) / (128.0 * 128.0));
  }

  int y1 = y1Temp * 100;
  int x2 = x2Temp * 100;

  if (abs (y1) < 10)
  {
  	y1 = 0;
  }

  if (abs (x2) < 10)
  {
    x2 = 0;
  }

  int rightSpeed = y1 + x2 * 2;
  int leftSpeed = y1 - x2 * 2;

  if(nMotorEncoder[lift1] > 2500  && !hangMode) //reduce speed when lift is up
  {
  	if(!lowering)
  	{
			if(x2 > 11 || x2 < -11)
			{
				motor[rightMotor] = 3*rightSpeed/8;
				motor[leftMotor] = 3*leftSpeed/8;
			}
			else
			{
				motor[rightMotor] = rightSpeed/2;
				motor[leftMotor] = leftSpeed/2;
			}
		}
		else
		{
			motor[rightMotor] = rightSpeed;
			motor[leftMotor] = leftSpeed;
		}
	}
	else
	{
		motor[rightMotor] = rightSpeed;
		motor[leftMotor] = leftSpeed;
	}
}

task runFlagLock()
{
	initialTurn = true;
	servo[flagLock] = 0;
	wait1Msec(1000);
	servo[flagLock] = 256;
}

void checkButtons()
{
	if(joy1Btn(1)) //raise flag
	{
		if(!initialTurn)
		{
			StartTask(runFlagLock);
		}
		motor[flag] = -100;
	}
	else  //reset
	{
		motor[flag] = 0;
	}

	if(joy1Btn(4)) //reverse intake
	{
		motor[intake] = -100;
	}
	else if(joy1Btn(2) || intakeOn) //turn intake on and set it so that the tray is just touching the ground
	{
		intakeOn = true;
		servo[rightDump] = 150;
	  servo[leftDump] = 125;
		wait1Msec(10);

		motor[intake] = 100;
	}
	else
	{
		motor[intake] = 0;
	}

	if(joy1Btn(3)) //turn intake off and set tray in upward position
	{
		intakeOn = false;
		motor[intake] = 0;

		servo[rightDump] = 90;
		servo[leftDump] = 158;
	  wait1Msec(10);
	}

	if(joy1Btn(5)) //drop tray
	{
	  servoChangeRate[leftDump] = 4;
	  servoChangeRate[rightDump] = 4;
		servo[rightDump] = 172;
	  servo[leftDump] = 110;
		wait1Msec(10);
  }
  else if(joy1Btn(6)) //raise tray
	{
	  servoChangeRate[leftDump] = 4;
	  servoChangeRate[rightDump] = 4;
		servo[rightDump] = 90;
		servo[leftDump] = 158;
		wait1Msec(10);
	}

	if(joy1Btn(7)) //drop lift to min using encoders
	{
		StopTask(raise);
		StartTask(lower);
	}
	else if(joy1Btn(8)) //raise lift to max using encoders
	{
		StopTask(lower);
		StartTask(raise);
	}

	if(joy1Btn(9)) //bring it down manually
	{
		motor[lift1] = -100;
		motor[lift2] = -100;
  }
	else if(joy1Btn(10)) //extend it up manually
	{
		motor[lift1] = 100;
		motor[lift2] = 100;
  }
	else //reset
	{
		motor[lift1] = 0;
		motor[lift2] = 0;
	}

	if(joy1Btn(12)) //lock the lift
	{
		servo[lock] = 90;
  }
	else if(joy1Btn(11)) //unlock the lift
	{
		servo[lock] = 60;
  }

	wait1Msec(10);
}


void dPadControl()
{
	if(joystick.joy1_TopHat == 0)
	{
		hangMode = false;
	}
	else if(joystick.joy1_TopHat == 2)
	{
		StartTask(runFlagLock);
	}
	else if(joystick.joy1_TopHat == 4)
	{
		hangMode = true;
	}
	else if(joystick.joy1_TopHat == 6)
	{
		servo[rightDump] = 240;
	  servo[leftDump] = 65;
		wait1Msec(100);
	}
}

/*task LEDIncrement()
{
	while(true)
	{
		if(joystick.joy1_TopHat == 2 || joystick.joy2_TopHat == 2)
		{
			LEDChange += 1;
		}
		wait1Msec(225);
	}
}

task LEDControl()
{
	while(true)
	{
		if(LEDChange == 0)
		{
			motor[LEDBottom] = 100;
			motor[LEDTop] = 100;
		}
		else if(LEDChange == 1)
		{
			motor[LEDBottom] = 0;
			motor[LEDTop] = 0;
		}
		else if(LEDChange == 2)
		{
			motor[LEDBottom] = 0;
			motor[LEDTop] = 100;
			wait10Msec(17);
			motor[LEDBottom] = 100;
			motor[LEDTop] = 0;
			wait10Msec(17);
		}
		else if(LEDChange == 3)
		{
			int inc = 0;
			while(inc < 5)
			{
				if(LEDChange != 3)
				{
					break;
				}
				inc++;
				motor[LEDTop] = 0;
				motor[LEDBottom] = 0;
				wait10Msec(120);
				motor[LEDBottom] = 100;
				wait10Msec(100);
				motor[LEDTop] = 100;
				wait10Msec(100);
				motor[LEDTop] = 0;
				motor[LEDBottom] = 0;
				wait10Msec(20);
				motor[LEDTop] = 100;
				motor[LEDBottom] = 100;
				wait10Msec(60);
			}
		}
		else if(LEDChange == 4)
		{
			int value = 0;
			int value2= 100;
			while(value < 100)
			{
				if(LEDChange != 4)
				{
					break;
				}
				value++;
				motor[LEDBottom] = value;
				value2--;
				motor[LEDTop] = value2;
				wait1Msec(20);
			}
			while(value2 < 100)
			{
				if(LEDChange != 4)
				{
					break;
				}
				value2++;
				motor[LEDTop] = value2;
				value--;
				motor[LEDBottom] = value;
				wait1Msec(20);
			}
		}
		else if(LEDChange == 5)
		{
			int val = 100;
			motor[LEDBottom] = val;
			wait10Msec(50);
			motor[LEDTop] = val;
			while(val > 0)
			{
				if(LEDChange != 5)
				{
					break;
				}
				val--;
				motor[LEDTop] = val;
				motor[LEDBottom] = val;
				wait10Msec(2);
			}
		}
		else if(LEDChange == 6)
		{
			LEDChange = 0;
		}
		wait1Msec(10);
	}
}*/

task main()
{
	waitForStart(); //wait for start of teleop phase

	hangMode = false;
	lifting = false;
	intakeOn = false;
	lowering = false;
	initialTurn = false;
	StopTask(runFlagLock);
	nMotorEncoder[lift1] = 0;
	servo[rightDump] = 90;
	servo[leftDump] = 158;
	servo[lock] = 60;
	servo[flagLock] = 256;
	wait1Msec(250);

	ClearTimer(T1);
	//motor[LEDBottom] = 100;
	//motor[LEDTop] = 100;
	//LEDChange = 0;
	//StartTask(LEDIncrement);
	//StartTask(LEDControl);

	while(true)
	{
		getJoystickSettings(joystick);
		drive();
		checkButtons();
		dPadControl();

		/*// LED Pulse
		if(inc)
		{
		  if(value < 100)
	  	{
	    	value++;
	    }
		  if (value == 100)
		  {
		    if(valueCounter < 20)
		  	{
		  		valueCounter++;
		  	}
		  	else
		  	{
		  		valueCounter = 0;
		  		inc = false;
		  	}
		  }
	  }
	  else
	  {
	  	if(value > 0)
	  	{
	    	value--;
	    }
		  else if(value == 0)
		  {
		  	if(valueCounter < 20)
		  	{
		  		valueCounter++;
		  	}
		  	else
		  	{
		  		valueCounter = 0;
		  		inc = true;
		  	}
			}
	  }

	  // LED Flash
	  counter++;
	  if (counter == 30)
	  {
	  	counter = 0;
	  }

		wait1Msec(10);*/
	}
}
